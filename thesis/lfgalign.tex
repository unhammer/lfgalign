% Created 2010-05-01 Sat 13:49
\documentclass[11pt,a4paper,oneside,draft]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[draft=false]{hyperref}
\usepackage[english,nynorsk]{babel} % or whatever language
\usepackage{apacite} % after babel
\usepackage{natbib}
\usepackage{graphics}
\usepackage[author=]{fixme}
\fxusetheme{colorsig}

\usepackage{amsmath} % for \operatorname

\usepackage{linguex} 

\usepackage{pslatex}
% \usepackage{pdfsync} % bug with glosses ( \exg. in linguex )

\usepackage{tikz-qtree}
\usepackage{avm}
\avmfont{\sc}
\avmoptions{sorted,active}
\avmvalfont{\rm}
\avmsortfont{\scriptsize\it}
\usepackage{algorithm2e}
\SetAlgorithmName{Funksjon}{fn}{liste over psevdokode}
%\SetAlgoFuncName{Funksjon}{} % for some reason gets no numbering TODO

\newcommand{\xbar}{$\rm\overline{X}$}
\newcommand{\F}[2]{\textsc{#1}\ensuremath{_{#2}}}
\newcommand{\OBLben}{\F{obl}{ben}}
\newcommand{\OBJben}{\F{obj}{ben}}
\newcommand{\OBJ}{\F{obj}{}}
\newcommand{\OBJs}{\F{obj~}{}}
\newcommand{\ADJ}{\F{adj}{}}
\newcommand{\ADJs}{\F{adj~}{}}
\newcommand{\XCOMP}{\F{xcomp}{}}
\newcommand{\XCOMPs}{\F{xcomp~}{}}
\newcommand{\SUBJ}{\F{subj}{}}
\newcommand{\SUBJs}{\F{subj~}{}}
\newcommand{\PRED}{\F{pred}{}}
\newcommand{\falign}{\ensuremath{\operatorname{\emph{falign}}}}
\newcommand{\fpairs}{\ensuremath{\operatorname{\emph{fpairs}}}}
\newcommand{\Bleu}{\textsc{Bleu}}

\title{Syntaktisk informert frasesamanstilling }
\author{Kevin Brubeck Unhammer}
\date{01/05, 2010}

\begin{document}

\maketitle

\setcounter{tocdepth}{4}
\tableofcontents
\vspace*{1cm}

\listoffixmes

\chapter{Introduksjon}
\chapter{Bakgrunn og relaterte metodar}
\chapter{Den ideelle frasesamanstillinga}
\chapter{Implementasjonen av \texttt{lfgalign}}
\label{sec-4}

\label{SEC:implementasjon}

For å finne ut av kor godt krava i forrige kapittel fungerer til å
avgrense kva for lenkjer som er moglege, har eg implementert dei etter
beste evne i eit Lisp\footnote{Dette språkvalet kan gjere eventuell integrering med andre
        LFG-system lettare (Common Lisp er m.a. nytta i LFG
        Parsebanker \citep{rosen2009lpt}). }-program.

\fxnote{intro TODO, kanskje noko om kva eg faktisk har fått ut av
implementasjonen} Ei implementering gjer det svært synleg om det finst
manglar i eit formelt krav, eller om noko ikkje er godt nok
spesifisert.

Programmet \texttt{lfgalign}\footnote{Tilgjengeleg frå \href{http://github.com/unhammer/lfgalign}{http://github.com/unhammer/lfgalign} som fri og
       open programvare under GNU General Public License. } tek inn LFG-analysane av to
setningar som me av uavhengige grunnar trur er omsetjingar av
kvarandre. LFG-analysane må vere disambiguerte og i Prolog-formatet
frå XLE\footnote{Formatet er dokumentert på
       \href{http://www2.parc.com/isl/groups/nltt/xle/doc/xle.html}{http://www2.parc.com/isl/groups/nltt/xle/doc/xle.html}. Importeringa
       til Lisp-strukturar handterer «pakka representasjonar» og
       kjenner igjen ekvivalensforhold (t.d. der fleire
       $\phi$-variablar refererer til same f-struktur, eller fleire
       Prolog-variabler refererer til same analyseval); men filene eg
       har testa utnyttar ikkje det fulle spennet til formatet, så det
       finst ganske sikkert feil. }. Programmet les inn dei to filene og opprettar ein
intern representasjon av LFG-analysen.  \fxnote{treng eg ein eigen del
om LPT i dette kapittelet? Implementasjonen er jo veldig enkel
iallfall.}

Me kan i tillegg gi programmet informasjon om kva for ord-omsetjingar
me ser på som lingvistisk prediktable. Intensjonen er at dette kan
vere informert av omsetjingstabellen frå eit automatisk
ordsamanstillingsprogram, eller av handskrivne omsetjingsordbøker.

Programmet byrjar lenkjinga med f-strukturane. Ei
f-struktur\emph{samanstilling} er ei mengd med \emph{lenkjer} mellom
individuelle f-strukturar. Resultatet av lenkjinga på dette nivået kan
vere tvitydig: sidan det ofte finst fleire måtar å lenkje argument og
adjunkt på, får me i første omgang mange samanstillingar mellom
kjelde- og mål-f-strukturar.

Difor rangerer me f-struktursamanstillingane, og den beste sender me
vidare til c-struktursamanstillinga. Denne delen av programmet gir ut
éi, utvitydig mengd med mange-til-mange-lenkjer mellom c-strukturane
(her treng me ingen rangering). Nodane i kvar av desse
mange-til-mange-lenkjene definerer no den endelege
frasesamanstillinga.

Nedanfor går eg gjennom detaljane rundt dei relevante delene av
programmet.

\section{Lenkjer mellom f-strukturar}
\label{sec-4.1}

\label{SEC:impl-f-lenkjing}

Hovudalgoritmen for lenkjing mellom f-strukturar er vist i kodefigur
\ref{algo:f-align}. Funksjonen \texttt{f-align} returnerer ei mengd med
moglege samanstillingar. Kvar samanstilling er ei mengd med par av
f-strukturar\footnote{Eigentleg eit slags avgjerdstre; kvart element er eit par, kor
        første element er lenkja mellom dei yttarste f-strukturane, og
        andre element er dei moglege samanstillingane for dei indre
        strukturane. Denne strukturen kan vere nyttig for å rangere
        samanstillingar, og \texttt{f-align} blir mykje meir oversiktleg av å
        jobbe med eit slikt tre. Ein funksjon \texttt{flatten} omformar det
        ferdige treet til ei enkel liste med samanstillingar, kor kvar
        samanstilling er ei flat liste med lenkjer mellom
        f-strukturar. }. Eit par $(F_s,F_t)$ representerer ei lenkje frå
ein f-struktur på kjeldespråket, til ein f-struktur på målspråket. Me
føreset at dette paret har LPT-korrespondanse\footnote{Når eg her skriv at to f-strukturar har LPT-korrespondanse,
        meiner eg sjølvsagt at ordformen til PRED-verdien til kvar
        f-struktur har LPT-korrespondanse. }, dette blir
sjekka før alle kall på \texttt{f-align}. Der me ikkje har informasjon om
LPT-korrespondanse mellom to ord (orda er ukjende), er lenkjing
lov. Pro-element og substantiv kan alltid lenkjast med kvarandre.

Hjelpefunksjonen \texttt{argalign} (som igjen kallar \texttt{argalign-p}, vist i
kodefigur \ref{algo:argalign-p}) gir alle moglege
«argumentpermutasjonar», dvs. moglege kombinasjonar av lenkjer mellom
argumenta til $F_s$ og $F_t$ som tilfredsstiller kravet om
LPT-korrespondanse, men utan å sjekke at desse argumenta igjen kan
samanstillast. Funksjonen prøver å lenkje kvart argument til eit
argument eller eit adjunkt, men gir ingen lenkjer mellom to adjunkt
(sjå del \ref{SEC:impl-adjalign} nedanfor om dette). Funksjonen gir
heller ikkje kombinasjonar der minst eitt argument ikkje er lenkja --
alle kombinasjonane må inkludere alle argument frå $F_s$ og $F_t$,
jf. krav (iii) og (iv) i \citet[s.~75]{dyvik2009lmp}. Elles er krav
(i) er tautologisk oppfylt, medan me som nemnt føreset at krav (ii) er
oppfylt før alle kall på \texttt{f-align}.

Eit døme: viss $F_s$ har argumenta \SUBJs og \OBJs og ingen adjunkt,
og $F_t$ har argumentet \SUBJs og eitt adjunkt \ADJ, der alle
ord-omsetjingar er moglege, vil \texttt{argalign} gi dei to samanstillingane
$\{(\SUBJ,\SUBJ), (\OBJ,\ADJ)\}$ og $\{(\SUBJ,\ADJ),
(\OBJ,\SUBJ)\}$. Viss adjunktet til $F_t$ ikkje fantest, eller ikkje
hadde LPT-korrespondanse med nokon av argumenta til $F_s$, ville me
ikkje fått nokon samanstillingar; medan viss paret $(\SUBJ,\SUBJ)$
ikkje hadde LPT-korrespondanse og alt anna var likt, ville me berre
fått den siste samanstillinga.

Funksjonen \texttt{f-align} går så gjennom kvar lenkje i kvar
argumentpermutasjon, og prøver å kalle \texttt{f-align} på alle
lenkjene. Sidan lenkjene som \texttt{argalign} gir har LPT-korrespondanse,
vil alle f-strukturane i dei rekursive kalla i \texttt{f-align} ha
LPT-korrespondanse. Eit rekursivt kall kan gi nye samanstillingar i
dei indre f-strukturane, viss dei relevante krava er oppfylte.

Det er mogleg at ei lenkje frå éi samanstilling kan finnast i andre
samanstillingar, me unngår dobbeltarbeid ved å lagre alle delvise
samanstillingar i tabellen $aligntable$. Dette føreset at
\texttt{f-align}$(s,t)$ er uavhengig av konteksten rundt; t.d. må
mengda av samanstillingar som kjem ved å lenkje subjektet til $F_s$
mot subjektet til $F_t$ vere uavhengig av om objektet til $F_s$ er
lenkja mot eit objekt eller eit adjunkt osb. av $F_t$. \fxnote{TODO:
nemne føresetnaden om uavhengnad i kapittel 3}

      \SetKwComment{Comment}{ // }{}
     \SetKwInOut{Input}{usage}
  
     \begin{algorithm}[]
      \caption{f-align($F_s$, $F_t$)}
      \label{algo:f-align}
      
      $alignments \gets \emptyset$  \;
      \ForAll{argperm in argalign($F_s$, $F_t$)} {
        $p \gets \emptyset$ \;
         \ForAll{$A_s$, $A_t$ in argperm} {
           \uIf{not(aligntable[$A_s$,$A_t$])} {
           aligntable[$A_s$,$A_t$] $\gets$ f-align($A_s$, $A_t$)\;
           }
          \uIf{aligntable[$A_s$,$A_t$]}{add aligntable[$A_s$,$A_t$] to $p$\;}
          \uElse{add $(A_s, A_t)$ to $p$}
        }
        add $p$ to $alignments$ \;
        \ForAll{adjperm in adjalign(argperm, $F_s$, $F_t$)} {
          $a \gets$ copy-of($p$) \Comment*[r]{optional adjunct links}
          \ForAll{$A_s$, $A_t$ in adjperm}{
            \uIf{not(aligntable[$A_s$,$A_t$])} {
              aligntable[$A_s$,$A_t$] $\gets$ f-align($A_s$, $A_t$)\;
            }
            \uIf{aligntable[$A_s$,$A_t$]}{add aligntable[$A_s$,$A_t$] to $a$\;}
            \uElse{add $(A_s, A_t)$ to $a$}
          }
          add $a$ to $alignments$ \;
        } % adjperm in adjalign
       } % argperm in argalign
       \Comment{loop through adjalign if no arguments exist}
       \lIf {$alignments=\emptyset$}{ \Return $\emptyset$ \Comment*[l]{Fail} }
       \lElse{ \Return $((F_s, F_t), alignments)$ \; }
       \end{algorithm}    
    
    
      \begin{algorithm}[]
      \caption{argalign-p($args_s$, $adjs_s$, $args_t$, $adjs_t$)}
      \label{algo:argalign-p}
    
      \Input{Kalt av argalign slik: \\ argalign-p(arguments($F_s$),
      adjuncts($F_s$), arguments($F_t$), adjuncts($F_t$))}
      \BlankLine
      
     $a \gets \emptyset$\;
     \uIf{$args_s$} {
           $s \in args_s$\;
           \ForAll{$t \in args_t$ \textbf{where} LPT($s$,$t$)} {
               \lForAll{$p \in$ argalign-p($args_s-\{s\}$, $adjs_s$, $args_t-\{t\}$,$adjs_t$)}{
  add $\{(s,t)\} \bigcup p$ to $a$\;
             }
            }
           \ForAll{$t \in adjs_t$ \textbf{where} LPT($s$,$t$)} {
               \lForAll{$p \in$ argalign-p($args_s-\{s\}$, $adjs_s$, $args_t$,$adjs_t-\{t\}$)}{
  add $\{(s,t)\} \bigcup p$ to $a$\;
                }
           }
             \Return $a$\;
         }
          \uElseIf{$args_t$} {
            \uIf{$adjs_s$}{
                $s \in adjs_s$\;
           \ForAll{$t \in args_t$ \textbf{where} LPT($s$,$t$)} {
               \lForAll{$p \in$ argalign-p($args_s$, $adjs_s-\{s\}$, $args_t-\{t\}$,$adjs_t$)}{
  add $\{(s,t)\} \bigcup p$ to $a$\;
             }
            }
             \Return $a$\;
        }\uElse{
              \Return $\emptyset$  \Comment*[l]{Fail}
            }
          }
        \uElse {
          \Return \{$\emptyset$\} \Comment*[l]{End}
        }     
      \end{algorithm}

Sjølv om det er krav om LPT-korrespondanse mellom kvart argument og
eit argument/adjunkt for å lenkje $F_s$ og $F_t$, er det ikkje noko
krav om at alle para i ein argumentpermutasjon tilfredsstiller alle
lenkjingskrava. Viss \texttt{f-align}$(\OBJ,\ADJ)$ frå dømet over gir
null, og ikkje kan lenkjast (t.d. fordi \ADJs hadde eitt argument, og
\OBJs ingen argument/adjunkt), medan \texttt{f-align}$(\SUBJ,\SUBJ)$
kan lenkjast, vil \texttt{f-align} likevel returnere samanstillinga som
inneheld $(\OBJ,\ADJ)$ og $(\SUBJ,\SUBJ)$. Me kan sjå i $aligntable$
for å finne ut av om kvar av f-strukturane kunne lenkjast; i dette
tilfellet vil $aligntable[\OBJ,\ADJ]$ vere tom.

\fxnote{TODO: forskjellen mellom LPT-krav og rekursjonskrav på argument må
inn i kapittel 3}

Om me i tillegg krev at substrukturar kan samanstillast kan me
utelukke lenkjing av f-strukturane $F_s$ og $F_t$ i \Next under:

{\avmoptions{}

\ex. \a.  \begin{avm}  \sort{$F_s$}{\[ {\sc pred} `{\bf planlegge}<{\it eg},[1:{\it gi}]>'\\
  {\sc xcomp} \sort{$^{1}$}{\[ {\sc pred} `{\it gi (opp)}'\]} \]}  \end{avm}
  \b.\begin{avm} \sort{$F_t$}{\[ {\sc pred} `{\bf plan}<{\it I},[2:{\it give}]>'\\
  {\sc xcomp} \sort{$^{2}$}{\[ {\sc pred} {\bf give}<{\it I},{\it him},{\it it}>' \]} \]} \end{avm}

}

Men det kan vere at me ikkje \emph{vil} krevje dette i alle moglege
tilfelle. Ei tryggare løysing er å rangere ulike løysingar i
etterkant, ved å spørje etter dei argumentsamanstillingane som har
flest medlem i $aligntable$, dette kjem eg tilbake til i
\ref{SEC:f-rangering} nedanfor.
\subsection{Overflødige adverbial}
\label{sec-4.1.1}

   \label{SEC:impl-adjalign}

Argumentpermutasjonane frå \texttt{argalign} prøver som nemnt ikkje reine
adjunkt-adjunkt-lenkjer, sidan me ikkje vil forkaste lenkjing av $F_s$
og $F_t$ berre på grunn av at ikkje alle adjunkt kunne lenkjast. Men
når me har prøvd ein argumentpermutasjon, kan me lage ein kopi av
denne som i tillegg inneheld lenkjer mellom «overflødige» adverbial,
altså dei adjunkt-adjunkt-lenkjene som \texttt{argalign} ikkje
prøver. Hjelpefunksjonen \texttt{adjalign} (ikkje vist her
\fxnote[inline,nomargin]{TODO: implementere :->}) konstruerer moglege
permutasjonar av lenkjer mellom adjunkt som ikkje er inkludert i
$argperm$, og \texttt{f-align} prøver desse rekursivt på same måte som med
argumentlenkjene. \fxnote{og så er det spørsmålet om me kan lenkje
adjunkt på ulike nivå i f-strukturane} Lenkjene blir lagt til ein
\emph{kopi} av argumentpermutasjonane, sidan det ikkje er sikkert at me
ønskjer å lenkje alle adjunktdøtre. Viss me har to overflødige adjunkt
på kvar side, og kravet om LPT-korrespondanse er dekkja for alle fire
moglege par, får me seks moglege permutasjonar, sidan me inkluderer
dei fire permutasjonane der eitt adjunktpar er ulenkja.

Viss $F_s$ og $F_t$ ikkje hadde argument i det heile teke, går me au
gjennom moglege permutasjonar av adjunktdøtre, på same måte (ikkje
vist i kodefigur \ref{algo:f-align}).

\subsection{\textbf{SKRIV} Når f-lenkjene ikkje er 1-1}
\label{sec-4.1.2}

\fxnote{Dette må 1. spesifiserast (kap.3), og 2. implementerast...}
\subsubsection{kausativ}
\label{sec-4.1.2.1}

\subsubsection{preposisjonsobjekt}
\label{sec-4.1.2.2}

``sigaretten'' og ``sigaretze'' er ikkje på same nivå i dei respektive
f-strukturane nedanfor:
\begin{verbatim}
 0[ PRED vedde<28,29,27,30>
    29[ PRED sigarett<> ] ]
\end{verbatim}


\begin{verbatim}
 0[ PRED da-najleveba<37,10,46>
    ADJUNCT { 2 }
    2[ ze<5>
       OBJ 5[ sigareti ] ] ]
\end{verbatim}




Sjå au del \ref{SEC:merge-daughters}.

\subsubsection{notat \textbf{:ROTETE:}}
\label{sec-4.1.2.3}

filene 
\begin{verbatim}
 ((tab_s (open-and-import "dev/TEST_argadj_s.pl"))
  (tab_t (open-and-import "dev/TEST_argadj_t.pl")))
\end{verbatim}

viser at me kan trenge samanføying av pred på ulike nivå.
\subsection{Kan me gjere f-struktursamanstillinga bottom-up?}
\label{sec-4.1.3}

  %     \begin{quotation}
  %    Any sufficiently complex problem needs to be coded three times.\\
  % \begin{minipage}{0.8\textwidth}
  % \begin{flushright}
  %        (ukjend, via Steve Gibson)
  % \end{flushright}
  % \end{minipage}
  %    \end{quotation}
Ein alternativ metode for lenkjing av f-strukturane er å byrje med
alle logisk moglege permutasjonar av LPT-korrespondansar, og så sile
ut dei som ikkje svarer til krava. Prosessen ville nok blitt mykje
meir oversiktleg på denne måten, sidan det då berre er snakk om å
sjekke krav for kvar enkelt lenkje.  Men ein slik metode er vanskeleg
i praksis; når avskjeringa skjer så seint, blir det alt for mange
moglege kombinasjonar for lengre setningar med mange ukjende ord til
at ein vanleg datamaskin kan halde styr på dei.

Me må i alle tilfelle vere klar for ei setning der alle ord er ukjende
(me har ingen informasjon om LPT-korrespondanse), slik at kvart
kjeldeord kan lenkjast til kvart målord. Viss båe setningane er 4 ord,
får me 16 moglege samanstillingar der alle ord er med i nøyaktig éi
lenkje ($2^l$, kor $l$ er setningslengd). Men ofte har me
null-lenkjer, me må altså i tillegg tillate samanstillingar der minst
eitt ord er ulenkja, utan at me treng å vite kva for ord det er; med
desse kortare listene inkludert får me endå fleire moglege
samanstillingar per setning (4 ord gir 26, 8 ord gir 2186 moglege
samanstillingar). Sjølv om me heile tida vel dei samanstillingane som
lenkjar flest ord, ville maskinen raskt fått problem. I tillegg har me
problemet med 1-mange-lenkjer, som skaper endå fleire moglege
samanstillingar.

Ein sideverknad av å byrje med ytre lenkjer og gå innover (prosessen
skildra i del \ref{SEC:impl-f-lenkjing}) er at me automatisk unngår å
prøve «kryssande» lenkjer, t.d. å lenkje $F_s$ med \XCOMPs av $F_t$, og
\XCOMPs av $F_s$ med $F_t$ (denne kombinasjonen av lenkjer vil jo vere
ein del av alle logisk moglege permutasjonar). Me får au prioritert å
lenkje ytre element, som jo er sikrare lenkjer: gitt to f-strukturar
for setningar der alt me veit om lenkjinga er at \emph{setningane} er
omsetjingar av kvarandre, vil dei to ytre f-strukturane ha størst
sjanse for å korrespondere med kvarandre. For kvart steg du går
innover må du multiplisere inn sjansen for å trå feil i
argumentpermutasjonane.

\section{\textbf{SKRIV} Rangering}
\label{sec-4.2}

\label{SEC:f-rangering}

\fxnote[inline,nomargin]{Rangering er ikkje implementert enno (akkurat no gir
rank(f-alignments) berre ut første samanstilling.)}
Rangering foregår etter ulike kriterium. Her er eit par forslag:
\subsection{rekursivt lenkja > ulenkja, men LPT}
\label{sec-4.2.1}

    $aligntable$ seier om noko er rekursivt lenkja eller ikkje,
    plusspoeng viss me har klart å lenkje rekursivt.
\subsection{argument-argument > argument-adjunkt}
\label{sec-4.2.2}

    Plusspoeng for argument-argument-lenkjer, burde vere eit bra
    kriterium, men me får sjølvsagt problem viss LPT ikkje seier noko
    i døme \ref{vedde} med \\
    \texttt{da-najleveba<Abrams,Browne,regne>} adjunkt: \texttt{sigarett}\\
    \texttt{bet<Abrams,sigarett,regne>} adjunkt: \texttt{Browne}
    
\subsection{arg1-arg1 arg2-arg2 > arg1-arg2 arg2-arg1 (følgje)}
\label{sec-4.2.3}

    Dette kjem til å gi problem når me vil lenkje «behage» og «like»,
    viss me ikkje har motstridande LPT-informasjon (og argumentfølgje
    i leksikon ikkje er basert på semantikk, men syntaks). Men elles
    er det vel OK.

    Enklaste implementasjon: Levenshtein-avstand. Men burde visse
    argument vektast? (T.d. vekte subjekt om alt anna er likt.)

    Andre forslag: \href{http://en.wikipedia.org/wiki/Edit_distance}{http://en.wikipedia.org/wiki/Edit\_distance})
\subsection{flest lenkja adjunkt}
\label{sec-4.2.4}

    Usikker på dette\ldots{} avheng av om me tillèt lenkjer på tvers av
    f-strukturar.
\subsection{Prioritet på rangeringskriterium}
\label{sec-4.2.5}

    Dette bør sjølvsagt testast empirisk, blir kanskje utanfor denne
    oppgåva (diskusjonsdel?), men kan jo prøve meg litt rundt.
\section{Lenkjing av c-strukturnodar}
\label{sec-4.3}

Samanstilling mellom f-strukturar treng i \texttt{lfgalign} ikkje informasjon
om c-strukturen, medan lenkjing av c-strukturnodar skjer på grunnlag
av f-struktursamanstillinga. Programmet utfører difor samanstilling av
c-strukturar sist.

Funksjonen \texttt{c-align} har som inndata c-strukturanalysane av kjelde- og
målsetninga, og éi f-struktursamanstilling; utdata er ei mengd med
lenkjer. Ei lenkje er eit par der første element er ei mengd
c-strukturnodar på kjeldespråket, og andre element ei mengd nodar på
målspråket. Det er ingen overlapp mellom medlem av lenkjer (ein node
er aldri med i meir enn eitt par).

I \citet[s.~77]{dyvik2009lmp} er kravet for å lenkje to
c-strukturnodar er at dei dominerer same mengd med
ordlenkjer\footnote{Dette er ein litt enklare måte å definere kravet på; ei
        \emph{lenkje} refererer til både kjelde og mål, dimed blir det
        mogleg å seie at ein node på kjeldespråket kan dominere same
        mengd som ein node på målspråket. }. Ein node \emph{n} dominerer ei mengd lenkjer \emph{l} viss
unionen av lenkjene dominert av døtrene til \emph{n} er lik \emph{l}. I
\texttt{lfgalign} opererer eg ikkje med \emph{ordlenkjer} i seg sjølv;
f-struktursamanstillinga er basert på LPT-korrespondansar, som
definerer moglege ordlenkjer utan å sjå på kontekst, og
f-struktursamanstillinga avgrenser vidare moglege ordlenkjer gitt
f-strukturinformasjon. Preterminale nodar er dei mest ordnære nodane
som kan ha ei f-strukturlenkje (ved $\phi$); når formålet er å lenkje
c-strukturnodar kan me nytte f-strukturlenkja til den preterminale
noden i staden for ordlenkjer.  \fxnote{To problem (kva vil me ha
med?)\\
1. me får \emph{ikkje} med LPT-korrespondansar som er OK, men
ikkje med i $f-alignment$;\\
2. me \emph{får} med LPT-korrespondansar
som er med i $f-alignment$ men ikkje $aligntable$ (ikkje er rekursivt
lenkja).}

 \begin{algorithm}[]
   \caption{c-align(f-alignment, $tree_s$, $tree_t$)}
   \label{algo:c-align}
    
   c-alignments $\gets \emptyset$ \;
   $splits_s \gets$ new table \;
   add-links(f-alignment, $tree_s, splits_s)$  \;
   $splits_t \gets$ new table \;
   add-links(f-alignment, $tree_t, splits_t)$  \;
   \ForAll{$links$ being the keys in $splits_s$} {
       \uIf{($links$ in $splits_t$)} {
             add $(splits_s[links],splits_t[links])$ to c-alignments \;
        }
    }
    \Return c-alignments \;
    \end{algorithm}    

Hjelpeprosedyren \texttt{add-links} utfører hovudjobben. Inndata er rotnoden
til c-strukturtreet for eitt av språka, og
f-samanstillinga. Prosedyren kappar opp treet i nodemengder, kor kvar
nodemengd dominerer same lenkjemengd (som definert over).
Nodemengdene blir lagra i ein tabell, indeksert på
lenkjemengdene. Prosedyren går rekursivt gjennom treet frå rot til
lauv; lenkjemengden for kvar node er unionen av lenkjemengdene
returnert av \texttt{add-links} kalt på kvar av døtrene. Viss ein node
dominerer ei lenkjemengd $links$, legg me til denne noden i tabellen
$splits[links]$. 

   \begin{algorithm}[]
   \caption{add-links(f-alignment, $node, splits$)}
   \label{algo:add-links}
      
        $links \gets \emptyset$\;
   \uIf{$node$} {
       \uIf{preterminal?($node$)} {
          let $link \in$ f-alignment s.t. $\phi(node) \in link$ \;
          \lIf{$link$} {$links \gets \{link\}$}
        }
        \uElse {
          $links \gets $add-links(f-alignment, left-branch($node$)) $\bigcup$ add-links(f-alignment, right-branch($node$)) \;
        }
        add $node$ to $splits[links]$ \;
       }
        \Return $links$ \;
  \end{algorithm}

Sidan \texttt{c-align} kallar \texttt{add-links} for kvar av sidene, får me to
tabellar $splits_s$ og $splits_t$. Me hentar så ut alle dei
lenkjemengdene som er i båe tabellane (dvs. snittet av oppslagsnøklene
til tabellen); nodane som er lagra med mengd med f-strukturlenkjer
skal lenkjast på c-strukturnivå. Alle desse mange-til-mange-lenkjene
blir til slutt returnert av \texttt{c-align}.

Prosessen er no ferdig, mange-til-mange-lenkjene mellom
c-strukturnodar definerer frasesamanstillinga

\fxnote[inline,nomargin]{til
diskusjonsdel:\emph{Det er ikkje berre ei N-gramsamanstilling; sidan
lenkjene er mellom c-strukturnodar kor kvar node dominerer ein
konstituent, kunne me kalt det ei} konstituentsamanstilling.}.


\subsection{\textbf{SKRIV} viss me har LPT, men ikkje rekursiv f-lenkje}
\label{sec-4.3.1}

    Dette bør kanskje vere valfritt i programmet, for å sjå kva det
    fører til: vil du ta med LPT-korrespondansar som ikkje har
    f-lenkjer i \texttt{add-links}?

    Og omvendt, finst det LPT-korrespondansar som ikkje kjem med i
    f-alignment i det heile teke, men som likevel burde ha noko å seie
    for c-strukturlenkjinga? (Men burde dei ikkje då vere med i
    f-alignment au?)

\fxnote{Kan me \textbf{fjerne} visse f-samanstillingar pga. c-strukturinfo?
    dvs. disambiguere...
    (dette er vel heller stoff for diskusjonsdelen?)}


\chapter{Diskusjon, resultat av å automatisk samanstille norske og georgiske setningar}
\chapter{Avslutning}
\label{sec-6}


\bibliographystyle{apacite}
\bibliography{master}


























\end{document}